#!/usr/bin/python3

import os
from os.path import *
import re
import json
import yaml
import ago
import sys
import signal
from sys import *
import argparse
import inspect
import traceback
from datetime import *
from prettytable import *
from git.exc import InvalidGitRepositoryError, GitCommandError
from munch import Munch
import git
from git.repo.base import Repo
import pandas as pd
from pprint import *

args = rest_args = None

fields = ("dir age count revision hash msg branch remote remote_head url linked state"
          .split())


def warn(a):
    print(a, file=sys.stderr)


def log(*_args, **kwargs):
    global args
    if args and 'verbose' in args and args.verbose:
        s1 = inspect.stack()[1]
        print("%s:%d %s < %s" %
              (s1.filename, s1.lineno, s1.function,
               inspect.stack()[2].function),
              str(*_args).rstrip(), file=sys.stderr, **kwargs)


def try_get(a):
    try:
        return a()
    except:
        return None

def git_get(g):
    m = Munch()
    r = Repo(g)
    if len(r.branches):
        m.branches = [b.name for b in r.branches]
    try:
        m.hash = r.git.rev_parse('--short', 'HEAD')
        m.sha = r.commit('HEAD').hexsha
        m.msg = r.head.object.message.split('\n')[0]
        m.count = int(r.git.rev_list('--count', 'HEAD'))
        m.time_sec = r.head.commit.committed_date
        m.datetime = r.head.commit.committed_datetime
        m.revision = r.git.describe(['--always', '--contains'])
    except GitCommandError:
        m.count = 0
        # without commit
        pass
    cr = r.config_reader()
    if islink(g + '/.git/config'):
        m.linked = dirname(relpath(realpath(g + '/.git/config')))

    if cr.has_option('core', 'worktree'):
        m.worktree = cr.get_value('core', 'worktree')
    # if r.head.is_detached:
    #    return m

    m.branch = try_get(lambda: r.active_branch.name)
    if not r.remotes:
        return m
    log(m)
    # if not m.count:
    #    return m

    tb = try_get(lambda: r.active_branch.tracking_branch())
    if tb:
        m.remote = tb.remote_name
    else:
        m.remote = r.remotes[0].name
    log(r.remotes[m.remote])
    m.url = try_get(lambda: r.remotes[m.remote].url)
    if not tb:
        return m
    m.remote = tb.remote_name
    log(m.remote)
    m.remote_head = tb.remote_head
    m.remote_sha = tb.commit.hexsha
    merge_base = r.merge_base(tb, 'HEAD')[0].hexsha
    m.to_push = int(r.git.rev_list('--count', str(tb) + '..HEAD'))
    if not m.to_push:
        del m.to_push
    m.to_pull = int(r.git.rev_list('--count', 'HEAD..' + str(tb)))
    if not m.to_pull:
        del m.to_pull
    return m


def git_compare(d, s):
    same = False
    if not exists(d + '/.git'):
        s.state = 'absent'
        log(d)
    else:
        r = Repo(d)
        if 'sha' in s:
            if s.sha != r.commit('HEAD').hexsha:
                s.state = 'different'
            elif (not r.head.is_detached and
                  r.active_branch.name == s.get('branch', '')):
                s.state = 'same'
                same = True
            else:
                s.state = 'same detached'
    return same


def git_import(d, s):
    if 'remote' not in s:
        return
    if exists(d + '/.git'):
        r = Repo(d)
    else:
        try:
            r = Repo.clone_from(s.url, d)
        except (AttributeError, GitCommandError) as e:
            r = Repo.init(d)
    if s.remote not in [a.name for a in r.remotes]:
        r.create_remote(s.remote, s.url)
        r.git.fetch(s.remote)
    if 'branch' in s:
        r.git.checkout(s.branch)
    if 'sha' not in s:
        return
    try:
        if s.sha != r.commit('HEAD').hexsha:
            r.git.checkout(s.sha)
        s.state = 'imported'
    except GitCommandError:
        s.state = 'failed'
        pass
    # assure same
    if s.sha == r.commit('HEAD').hexsha:
        s.state += ' same'


def xstr(s):
    return '' if s is None else str(s)


def short(s, right=True):
    if not s or len(s) <= 16:
        return xstr(s)
    if right:
        return s[:15] + '…'
    else:
        return '…' + s[-15:]


def parse_args():
    ap = argparse.ArgumentParser()
    ap.add_argument('--table', nargs='?', default=argparse.SUPPRESS)
    ap.add_argument('--sha', nargs='?', default=argparse.SUPPRESS,
                    help='print sha hashes in format of sha1sum utility '
                    'optionally to a file')
    ap.add_argument('--csv', nargs='?', default=argparse.SUPPRESS,
                    help='print in format csv')
    ap.add_argument('--json', nargs='?', default=argparse.SUPPRESS)
    ap.add_argument('--export', nargs='?', default=argparse.SUPPRESS,
                    help='scans directory tree and saves results '
                    'to default status.yaml or specified another file. '
                    'Can be "-" for standart output.')
    ap.add_argument('--compare', nargs='?', default=argparse.SUPPRESS,
                    help='scans directory tree and compares with status.yaml')
    ap.add_argument('--import', nargs='?', default=argparse.SUPPRESS,
                    help='scans directory tree and '
                    'synchronizes with default status.yaml '
                    'or specified another file. '
                    'Can be "-" for standart input.')
    ap.add_argument('--standalone_remote', action='store_true',
                    help='Skips linked (not standalone) '
                    'repositories and without remotes. '
                    'Leaves only unlinked standalone with remotes. '
                    'Linked reps belong to git submodules or repo. '
                    'This reps can be replicated with parent git or repo. '
                    'Reps without remote can\'t be synced via remote.')
    ap.add_argument('--since', nargs=1)
    ap.add_argument('rest', metavar='...', nargs='?', default='.',
                    help='directory for export or compare, '
                    'or git command with arguments. '
                    'When argument is existed file or directory the git '
                    'command will be executed for that location, '
                    'even current directory is outer to git repository. '
                    'When arguments of the specified git command '
                    'are not existed files/dirs the command '
                    'will be executed for all exported git directories.'
                    )
    ap.add_argument('--verbose', action='store_true')
    global args, rest_args
    args, rest_args = ap.parse_known_args()


def print_csv(p, st):
    print(", ".join(
        [p, xstr(st.get('datetime', '')), xstr(st.get('count', 0)),
            st.get('sha', ''), '"%s"' % (st.get('msg', '')),
            xstr(st.get('branch', '')),
            st.get('worktree', st.get('linked', 'standalone')),
            (st.get('remote', 'local') + ' ' + xstr(st.get('url', ''))),
            st.get('state', '')
         ]
    ))


def print_sha(p, st):
    print("%s  %s" % (st.sha, p)) if 'sha' in st else 0


class GitM(object):

    def __init__(self):
        self.loaded = self.out = self.tab = None
        self.status = {}

    def process_args(self):
        rep = {'same': '=', 'detached': '/', 'different': '*',
               'undesired': '-', 'absent': '+', 'imported': '<',
               'failed': '!'}
        pattern = re.compile("|".join(rep.keys()))

        def table_add_row(p, st):

            def age(s):
                global ago
                return short(ago.human(datetime.fromtimestamp(s),
                                       1, '{}', '{}', True))

            r = {}
            r['dir'] = short(p, False)
            r.update(dict(st))
            r['msg'] = short(r.get('msg', ''))
            if 'time_sec' in st:
                r['age'] = age(st.time_sec)
            r['branch'] = short(r.get('branch', ''))
            r['revision'] = short(r.get('revision', ''), False)
            r['url'] = short(r.get('url', ''), False)
            r['linked'] = short(r.get('linked', ''), False)
            r['state'] = pattern.sub(lambda m: rep[re.escape(m.group(0))],
                                     r.get('state', ''))
            self.tab.add_row([r[f] if f in r else '' for f in fields])

        if 'compare' in args:
            if not args.compare:
                args.compare = "status.yaml"
                if not isfile(args.compare):
                    args.compare = "status.json"
            log(args.compare)
            with open(args.compare) as f:
                if args.compare.endswith('.yaml'):
                    self.loaded = Munch(yaml.load(f))
                if args.compare.endswith('.json'):
                    self.loaded = Munch(json.load(f))
        else:
            fn = vars(args).get('import', None)
            fn = fn if fn else 'status.yaml'
            if 'export' not in args and (isfile(fn) or fn == '-'):
                if fn == '-':
                    f = sys.stdin
                else:
                    f = open(fn)
                self.loaded = Munch(yaml.load(f))
                f.close()

        self.out = print_sha if 'sha' in args else self.out

        self.out = print_csv if 'csv' in args else self.out

        if not self.out:  # default output is table
            self.tab = PrettyTable(fields,
                                   border=False)
            self.tab._left_padding_width = 0
            rights = ('age', 'count')
            for f in fields:
                self.tab.align[f] = 'r' if f in rights else 'l'
            self.out = table_add_row

    def git_for_subdir(self):
        log()
        # print(args.rest, rest_args)
        dir = arg = ''
        # TODO: check all arguments
        if isfile(rest_args[-1]):
            dir = dirname(rest_args[-1])
            arg = basename(rest_args[-1])
        elif isdir(rest_args[-1]):
            dir = rest_args[-1]
        else:
            raise("Neither file or dir: " + dir)
        log(dir)
        log(arg)
        cmd = ' '.join(["git -C", dir, args.rest] +
                       rest_args[:-1] + [arg])
        log(cmd)
        ret = os.system(cmd)
        return os.WEXITSTATUS(ret)

    def git_for_each(self):
        log()
        ret = 0
        for d, s in self.loaded.items() if self.loaded else {}:
            print("project", d)
            r = os.system(' '.join(["git -C", d, args.rest] + rest_args))
            if os.WTERMSIG(r) == signal.SIGINT:
                raise KeyboardInterrupt
            log(r)
            if r:
                ret = r
        return os.WEXITSTATUS(ret)

    def scan(self, d):
        warn('Scanning directory tree ...')
        status = {}
        for path, dirs, files in os.walk(d):
            (dir, base) = split(path)
            p = re.sub(r'^\.\/', '', path)
            log(p)
            if base in ['.git', 'tmp']:
                dirs[:] = []  # prune
                continue
            if not ('.git' in files or '.git' in dirs):
                continue

            try:
                st = git_get(p)
                # Get only remote and standalone if requested
                if (args.standalone_remote and
                        ('remote' not in st or
                         'linked' in st or
                         'worktree' in st)):
                    continue
                status[p] = dict(st)
                if 'compare' in args and self.loaded and p not in self.loaded:
                    # only here and not in compare
                    st.state = 'undesired'
                    self.out(p, st)
                if not self.loaded:
                    self.out(p, st)
            except (InvalidGitRepositoryError,
                    GitCommandError, ValueError) as e:
                warn(repr(e) +
                     (': ' + p if p not in repr(e) else ''))
        return status

    def compare(self):
        for d, s in self.loaded.items() if self.loaded else {}:
            try:
                s = Munch(s)
                if args.since and s.get('datetime', datetime.now()) < pd.to_datetime(args.since):
                    continue
                if not git_compare(d, s) and 'import' in args:
                    git_import(d, s)
                self.out(d, s)
                self.status[d] = dict(s)
            except (InvalidGitRepositoryError, GitCommandError,
                    ValueError) as e:
                warn('Error: ' + str(e) +
                     (': ' + d if d not in str(e) else ''))
                traceback.print_exc()

    def output(self):
        if 'json' in args:
            if not args.json:
                args.json = "status.json"
            if args.json == '-':
                f = sys.stdout
            else:
                f = open(args.json, "w")
            f.write(json.dumps(self.status, indent=4, default=str) + "\n")
            f.close()

        log(args)
        if 'export' in args:
            if not args.export:
                args.export = "status.yaml"
            if args.export == '-':
                f = sys.stdout
            else:
                f = open(args.export, "w")
            f.write(yaml.dump(self.status,
                              default_flow_style=False, default_style=''))
            f.close()
            warn('Exported status into file ' + args.export)
            return

        print(self.tab) if self.tab else 0


    def main(self):
        parse_args()
        self.process_args()
        log(self.loaded)

        if (isdir(args.rest)
           and (not self.loaded or 'compare' in args or 'export' in args)):
            # don't scan if self.loaded and not in compare mode
            self.status = self.scan(args.rest)
        # assume git command with an argument
        elif rest_args and exists(rest_args[-1]):
            return self.git_for_subdir()
        # assume git command without an argument
        elif not isdir(args.rest):
            return self.git_for_each()

        # do comprare without scan even when 'compare' not in args.
        self.compare()
        self.output()


if __name__ == "__main__":
    err = GitM().main()
    if err:
        sys.exit(err)
